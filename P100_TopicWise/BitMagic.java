package P100_TopicWise;


import javax.imageio.plugins.tiff.TIFFImageReadParam;

public class BitMagic {

    // 1. You are given a number N. Find the total count of set bits for all
    // numbers from 1 to N(both inclusive).

    public static int countSetBits(int n)
    {
        // visualise it as pattern of repeating 1's and 0's when u look at
        // only lsb or the bits next to it and like that for every single number

        n+=1; // because we gotta include 0
        int tot=0;
        int tp = 2; // first pattern in of length 2;
        int ext;
        while((n>=(tp/2))){ // n>=tp/2 because we need the msb bits which
            // contribute to the extra tp bit 1.
            tot = tot + (n/tp)*(tp/2); // bits in complete pattern
            ext = Math.max(((n % tp) - (tp / 2)), 0); // bits extra
            tot = tot +ext;
            tp*=2; // update with tp*2

        }
        return tot;

    }

    // IMPORTANT FORMULAE :
    // 1. n>>=2 : n/=2
    // 2. n&(n-1) : Flip the last set bit
    // 3. n&(~(n-1)) : Only keep the last set bit as set : highest pow of 2
    // that can divide n
    // 4. HexaDecimal numbers : 0xAAAAAAAA : 32 bit number with only even bits
    // set ; 0x55555555 : 32 bit number with only odd bits set



    //2. Given an array arr[] of N positive elements. The task is to find the
    // Maximum AND Value generated by any pair(arri, arrj) from the array such that i != j.
    //Note: AND is bitwise '&' operator.
    public static int maxAND_fun1 (int[] arr, int a)
    {
        int count=0;
        for (int j : arr) {
            if ((j & a) == a) {
                count++;
            }

        }
        return count;

    }


    public static int maxAND (int[] arr, int N)
    {
        int a=1;
        a<<=30;
        int pattern=0;
        int count;
        while(a>0){

        count = maxAND_fun1(arr, (pattern|a));
            if (count >= 2) {
                pattern = pattern | a;
            }
            a>>=1;
        }
        return pattern;
    }

    //3. You are given a decimal number N. You need to find the gray code of
    // the number N and convert it into decimal.
    // No need of decimal to binary conversion if we use Biwise operators.

    public static int greyConverter(int n) {

        // Your code here
        return ((n)^(n>>1)); // From Binary to Grey => Sinply do xor with its
        // right-shifted self.

    }


    // 4. Given an integer number n, which is a decimal representation of
    // Gray Code. Find the binary equivalent of the Gray Code & return the
    // decimal representation of the binary equivalent.

    public static int grayToBinary(int n) {
        int res=0;
        // Your code here
        while(n>0){
            res^=n;
            n>>=1;
        }
        return res;

    }



    public static void main(String[] args) {
        System.out.println("BitMagic");
        int[] arr = {4,8,12,16};
        int N = 4;
        int x = maxAND (arr, N);
        System.out.println(x);
    }
}
